1.
메모리를 적절히 사용하여 수행시간 효율성을 비약적으로 향상 시키는 방법
이미 계산된 결과는 메모리에 저장하여 다시 계산하지 않음
탑다운 or 바텀업
동적 계획법 이라고도 한다.
동적 할당이란 원래 프로그램이 실행되는 도중에 필요한 메모리를 할당하는 기법이다.
하지만 다이나믹 프로그래밍에서 다이나믹은 별 의미 없이 사용된 단어이다.


2. 사용 조건
(1) 최적 부분 구조
- 큰문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결 할 수 있다.
(2) 중복되는 부분 문제
- 동일한 작은 문제를 반복적으로 해결하는 문제.


3. 예시
피보나치 수열
1 1 2 3 5 8 13 21 34 55 89
앞의 두수를 더한 수.
a(n) = a(n-1) + a(n-2) ,  a1 = 1, a2= 1
위와 같이 수열 형태로 점화식을 표현할 수 있다.


4. 단순 재귀 코드
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))

단점 : f(6)을 위해서 f(5)와 f(4)가 필요한데 각각을 구하기 위해 f(3)..이하가 중복적으로 실행된다
지수시간 복잡도를 가지게 된다. f(30)은 10억가량의 연산이 필요하다.
피보나치는 큰 문제를 나눌 수 있고, 중복되는 연산이 있다. 다이나믹 프로그래밍을 사용할 수 있다.


5. 메모제이션
한번 계산한 결과를 메모리 공간에 메모(캐싱) 한다.
하향식 방법으로 접근할 때 메모제이션을 사용할 수 있다.


6. 탐다운 다이나믹 프로그래밍 소스코드
d = [0] * 100

def fibo(x):
    if x == 1 or x == 2:
        return 1

    if d[x] != 0:
        return d[x]

    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))


7. 바텀업 다이나믹 프로그래밍 소스코드
d = [0] * 100
d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i -1] + d[i-2]

print(d[n])

8. 위 예시에서 시간복잡도
O(2^N) 에서 O(N)


9. 분할 정복과의 차이점
둘다 큰 문제를 작은 문제로 쪼갤 수 있는 상황.
다만 다이나믹 프로그래밍은 부분 문제가 중복이 되는 것이다.


10. 문제 풀때 팁
주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이 중요하다.
가장 먼저 그리디, 구현, 완전 탐색의 아이디어로 해결할 수 있는지 검토
재귀 함수로 비효율적인 완전탐색 프로그래밍을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서
그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있다.















